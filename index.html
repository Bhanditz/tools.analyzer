<html>
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
    <title>clojure.tools.analyzer - Analyzer for Clojure code 0.5.4 API documentation</title>
    <link href="static/favicon.png" rel="icon" />
    <link href="static/favicon.png" rel="shortcut icon" />
    <link media="all" type="text/css" href="static/clojure.css" rel="stylesheet" />
    <link media="all" type="text/css" href="static/wiki.css" rel="stylesheet" />
    <link media="all" type="text/css" href="static/internal.css" rel="stylesheet" />
    <style>.menuWrapper{height: 36px;}</style>
  </head>
<!--
This document was auto-generated from the source by the clojure autodoc system.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
-->
  <body>
    <div id="AllContentContainer">
      <div id="Header">
	<a id="Logo" href="index.html"><img alt="Clojure" height="100" width="100" src="static/clojure-icon.gif" /></a>
	<h1><a title="page header title" id="page-header" href="index.html">tools.analyzer API Reference</a></h1>
      </div>
      <div id="leftcolumn"><div style="text-align: center;"></div>
<div class="menu">
  <div class="WikiCustomNav WikiElement wiki">
    <span class="toc-header"><span id="project-name">Analyzer for Clojure code</span> <span id="version">0.5.4</span> API</span><br />
    <ul>
      <li><a class="wiki_link" href="index.html">Overview</a></li>
      <li><a class="wiki_link" href="api-index.html">API Index</a></li>
    </ul>
    
    
    <a href="http://clojure.org" class="wiki_link">Clojure Home</a>
  </div>
</div>
</div>
      <div id="rightcolumn">
	<div id="Content">
	  <div class="contentBox"><div class="innerContentBox">
              <div id="content_view" class="wiki wikiPage">
                <div id="right-sidebar"><div id="toc">
  <h1 class="nopad">Table of Contents</h1>
  <div style="margin-left: 1em;" class="toc-section">
    <a href="#toc0" style="margin-top: 3px;">Overview</a>
    
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#" style="margin-top: 3px;"></a>
    
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#" style="margin-top: 3px;"></a>
    
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#var-section" style="margin-top: 3px;">Vars and Functions</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer/-parse">-parse</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer/analyze">analyze</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer/analyze-form">analyze-form</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer/analyze-in-env">analyze-in-env</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer/create-var">create-var</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer/empty-env">empty-env</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer/macroexpand">macroexpand</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer/macroexpand-1">macroexpand-1</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer/parse">parse</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer/specials">specials</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer/var?">var?</a>
      
    </div>
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.tools.analyzer.ast" style="margin-top: 3px;">clojure.tools.analyzer.ast</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.ast/ast-&gt;eav">ast-&gt;eav</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.ast/children">children</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.ast/children*">children*</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.ast/cycling">cycling</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.ast/nodes">nodes</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.ast/postwalk">postwalk</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.ast/prewalk">prewalk</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.ast/update-children">update-children</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.ast/walk">walk</a>
      
    </div>
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.tools.analyzer.ast.query" style="margin-top: 3px;">clojure.tools.analyzer.ast.query</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.ast.query/db">db</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.ast.query/q">q</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.ast.query/query-map">query-map</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.ast.query/resolve-calls">resolve-calls</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.ast.query/unfold-expression-clauses">unfold-expression-clauses</a>
      
    </div>
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.tools.analyzer.env" style="margin-top: 3px;">clojure.tools.analyzer.env</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.env/*env*">*env*</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.env/deref-env">deref-env</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.env/ensure">ensure</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.env/with-env">with-env</a>
      
    </div>
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.tools.analyzer.passes" style="margin-top: 3px;">clojure.tools.analyzer.passes</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.passes/schedule">schedule</a>
      
    </div>
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.tools.analyzer.passes.add-binding-atom" style="margin-top: 3px;">clojure.tools.analyzer.passes.add-binding-atom</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.passes.add-binding-atom/add-binding-atom">add-binding-atom</a>
      
    </div>
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.tools.analyzer.passes.collect-closed-overs" style="margin-top: 3px;">clojure.tools.analyzer.passes.collect-closed-overs</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.passes.collect-closed-overs/collect-closed-overs">collect-closed-overs</a>
      
    </div>
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.tools.analyzer.passes.constant-lifter" style="margin-top: 3px;">clojure.tools.analyzer.passes.constant-lifter</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.passes.constant-lifter/constant-lift">constant-lift</a>
      
    </div>
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.tools.analyzer.passes.elide-meta" style="margin-top: 3px;">clojure.tools.analyzer.passes.elide-meta</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.passes.elide-meta/elide-meta">elide-meta</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.passes.elide-meta/elides">elides</a>
      
    </div>
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.tools.analyzer.passes.emit-form" style="margin-top: 3px;">clojure.tools.analyzer.passes.emit-form</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.passes.emit-form/-emit-form*">-emit-form*</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.passes.emit-form/emit-form">emit-form</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.passes.emit-form/emit-hygienic-form">emit-hygienic-form</a>
      
    </div>
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.tools.analyzer.passes.index-vector-nodes" style="margin-top: 3px;">clojure.tools.analyzer.passes.index-vector-nodes</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.passes.index-vector-nodes/index-vector-nodes">index-vector-nodes</a>
      
    </div>
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.tools.analyzer.passes.source-info" style="margin-top: 3px;">clojure.tools.analyzer.passes.source-info</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.passes.source-info/source-info">source-info</a>
      
    </div>
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.tools.analyzer.passes.uniquify" style="margin-top: 3px;">clojure.tools.analyzer.passes.uniquify</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.passes.uniquify/uniquify-locals">uniquify-locals</a>
      
    </div>
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.tools.analyzer.passes.warn-earmuff" style="margin-top: 3px;">clojure.tools.analyzer.passes.warn-earmuff</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.passes.warn-earmuff/warn-earmuff">warn-earmuff</a>
      
    </div>
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.tools.analyzer.utils" style="margin-top: 3px;">clojure.tools.analyzer.utils</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.utils/-source-info">-source-info</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.utils/arglist-for-arity">arglist-for-arity</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.utils/boolean?">boolean?</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.utils/butlast+last">butlast+last</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.utils/classify">classify</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.utils/const-val">const-val</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.utils/constant?">constant?</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.utils/ctx">ctx</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.utils/dissoc-env">dissoc-env</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.utils/dynamic?">dynamic?</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.utils/into!">into!</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.utils/macro?">macro?</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.utils/mmerge">mmerge</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.utils/obj?">obj?</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.utils/private?">private?</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.utils/protocol-node?">protocol-node?</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.utils/record?">record?</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.utils/reference?">reference?</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.utils/regex?">regex?</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.utils/resolve-ns">resolve-ns</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.utils/resolve-var">resolve-var</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.utils/rseqv">rseqv</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.utils/source-info">source-info</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.utils/type?">type?</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.utils/update-keys">update-keys</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.utils/update-kv">update-kv</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.tools.analyzer.utils/update-vals">update-vals</a>
      
    </div>
  </div>
</div>
</div>
                <div id="content-tag"><h1 id="overview">API for <span id="clojure.tools.analyzer">clojure.tools.analyzer</span>
  - <span id="header-project">Analyzer for Clojure code</span> <span id="header-version">0.5.4</span><span id="header-status-block"> (<span id="header-status">in development</span>)</span>
  </h1>

<br />Full namespace name: <span id="long-name">clojure.tools.analyzer</span>
<p></p>
<h2>Overview</h2>
<div id="home-page">Project home page is <a href="http://github.com/clojure/tools.analyzer/">http://github.com/clojure/tools.analyzer/</a></div>
<pre id="namespace-docstr">Analyzer for clojure code, host agnostic.

Entry point:
* analyze

Platform implementers must provide dynamic bindings for:
* macroexpand-1
* parse
* create-var
* var?

Setting up the global env is also required, see clojure.tools.analyzer.env

See clojure.tools.analyzer.core-test for an example on how to setup the analyzer.</pre>


<br />



<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer/-parse">-parse</h2>
    <span id="var-type">multimethod</span><br />
    <pre id="var-usage">No usage documentation available</pre>
    <pre id="var-docstr">Takes a form and an env map and dispatches on the head of the form, that is
a special form.</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/5fe8d5d67d3ee64babe4e18fa2de122e3853f07c/src/main/clojure/clojure/tools/analyzer.clj#L37" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer/analyze">analyze</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (analyze form env)
</pre>
    <pre id="var-docstr">Given a form to analyze and an environment, a map containing:
* :locals     a map from binding symbol to AST of the binding value
* :context    a keyword describing the form's context from the :ctx/* hierarchy.
 ** :ctx/return    the form is in return position
 ** :ctx/statement the return value of the form is not needed
 ** :ctx/expr      the form is an expression, it's value is used
 Derived from :ctx/expr
 ** :ctx.invoke/target  the form is an expression that is invoked as a function
 ** :ctx.invoke/param   the form is an expression used as parameter in a function call
* :ns         a symbol representing the current namespace of the form to be
              analyzed

returns an AST for that form.

Every node in the AST is a map that is *guaranteed* to have the following keys:
* :op   a keyword describing the AST node
* :form the form represented by the AST node
* :env  the environment map of the AST node

Additionaly if the AST node contains sub-nodes, it is guaranteed to have:
* :children a vector of the keys of the AST node mapping to the sub-nodes,
            ordered, when that makes sense

It is considered a node either the top-level node (marked with :top-level true)
or a node that can be reached via :children; if a node contains a node-like
map that is not reachable by :children, there's no guarantee that such a map
will contain the guaranteed keys.</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/5fe8d5d67d3ee64babe4e18fa2de122e3853f07c/src/main/clojure/clojure/tools/analyzer.clj#L93" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer/analyze-form">analyze-form</h2>
    <span id="var-type">dynamic multimethod</span><br />
    <pre id="var-usage">No usage documentation available</pre>
    <pre id="var-docstr">Like analyze, but does not mark the form with :top-level true</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/5fe8d5d67d3ee64babe4e18fa2de122e3853f07c/src/main/clojure/clojure/tools/analyzer.clj#L45" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer/analyze-in-env">analyze-in-env</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (analyze-in-env env)
</pre>
    <pre id="var-docstr">Takes an env map and returns a function that analyzes a form in that env</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/5fe8d5d67d3ee64babe4e18fa2de122e3853f07c/src/main/clojure/clojure/tools/analyzer.clj#L132" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer/create-var">create-var</h2>
    <span id="var-type">dynamic function</span><br />
    <pre id="var-usage">Usage: (create-var sym env)
</pre>
    <pre id="var-docstr">Creates a var for sym and returns it</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/5fe8d5d67d3ee64babe4e18fa2de122e3853f07c/src/main/clojure/clojure/tools/analyzer.clj#L148" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer/empty-env">empty-env</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (empty-env)
</pre>
    <pre id="var-docstr">Returns an empty env</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/5fe8d5d67d3ee64babe4e18fa2de122e3853f07c/src/main/clojure/clojure/tools/analyzer.clj#L125" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer/macroexpand">macroexpand</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (macroexpand form env)
</pre>
    <pre id="var-docstr">Repeatedly calls macroexpand-1 on form until it no longer
represents a macro form, then returns it.</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/5fe8d5d67d3ee64babe4e18fa2de122e3853f07c/src/main/clojure/clojure/tools/analyzer.clj#L234" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer/macroexpand-1">macroexpand-1</h2>
    <span id="var-type">dynamic function</span><br />
    <pre id="var-usage">Usage: (macroexpand-1 form env)
</pre>
    <pre id="var-docstr">If form represents a macro form, returns its expansion,
else returns form.</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/5fe8d5d67d3ee64babe4e18fa2de122e3853f07c/src/main/clojure/clojure/tools/analyzer.clj#L137" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer/parse">parse</h2>
    <span id="var-type">dynamic function</span><br />
    <pre id="var-usage">Usage: (parse [op &amp; args] env)
</pre>
    <pre id="var-docstr">Multimethod that dispatches on op, should default to -parse</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/5fe8d5d67d3ee64babe4e18fa2de122e3853f07c/src/main/clojure/clojure/tools/analyzer.clj#L143" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer/specials">specials</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">Set of special forms common to every clojure variant</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/5fe8d5d67d3ee64babe4e18fa2de122e3853f07c/src/main/clojure/clojure/tools/analyzer.clj#L228" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer/var?">var?</h2>
    <span id="var-type">dynamic function</span><br />
    <pre id="var-usage">Usage: (var? obj)
</pre>
    <pre id="var-docstr">Returns true if obj represent a var form as returned by create-var</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/5fe8d5d67d3ee64babe4e18fa2de122e3853f07c/src/main/clojure/clojure/tools/analyzer.clj#L153" id="var-source">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.tools.analyzer.ast">clojure.tools.analyzer.ast</h2>
<pre id="namespace-docstr">Utilities for AST walking/updating</pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.ast/ast-&gt;eav">ast-&gt;eav</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (ast-&gt;eav ast)
</pre>
    <pre id="var-docstr">Returns an EAV representation of the current AST that can be used by
Datomic's Datalog.</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/0bda3061cb95162feafb94a288422ae18767b07a/src/main/clojure/clojure/tools/analyzer/ast.clj#L107" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.ast/children">children</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (children ast)
</pre>
    <pre id="var-docstr">Return a vector of the children expression of the AST node, if it has any.
The children expressions are kept in order and flattened so that the returning
vector contains only nodes and not vectors of nodes.</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/0bda3061cb95162feafb94a288422ae18767b07a/src/main/clojure/clojure/tools/analyzer/ast.clj#L35" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.ast/children*">children*</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (children* {:keys [children], :as ast})
</pre>
    <pre id="var-docstr">Return a vector of vectors of the children node key and the children expression
of the AST node, if it has any.
The returned vector returns the childrens in the order as they appear in the
:children field of the AST, and the children expressions may be either a node
or a vector of nodes.</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/0bda3061cb95162feafb94a288422ae18767b07a/src/main/clojure/clojure/tools/analyzer/ast.clj#L25" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.ast/cycling">cycling</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (cycling &amp; fns*)
</pre>
    <pre id="var-docstr">Combine the given passes in a single pass that will be applieed repeatedly
to the AST until applying it another time will have no effect</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/0bda3061cb95162feafb94a288422ae18767b07a/src/main/clojure/clojure/tools/analyzer/ast.clj#L13" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.ast/nodes">nodes</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (nodes ast)
</pre>
    <pre id="var-docstr">Returns a lazy-seq of all the nodes in the given AST, in depth-first pre-order.</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/0bda3061cb95162feafb94a288422ae18767b07a/src/main/clojure/clojure/tools/analyzer/ast.clj#L101" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.ast/postwalk">postwalk</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (postwalk ast f)
       (postwalk ast f reversed?)
</pre>
    <pre id="var-docstr">Shorthand for (walk ast identity f reversed?)</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/0bda3061cb95162feafb94a288422ae18767b07a/src/main/clojure/clojure/tools/analyzer/ast.clj#L93" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.ast/prewalk">prewalk</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (prewalk ast f)
</pre>
    <pre id="var-docstr">Shorthand for (walk ast f identity)</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/0bda3061cb95162feafb94a288422ae18767b07a/src/main/clojure/clojure/tools/analyzer/ast.clj#L87" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.ast/update-children">update-children</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (update-children ast f)
       (update-children ast f reversed?)
</pre>
    <pre id="var-docstr">Applies `f` to each AST children node, replacing it with the returned value.
If reversed? is not-nil, `pre` and `post` will be applied starting from the last
children of the AST node to the first one.</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/0bda3061cb95162feafb94a288422ae18767b07a/src/main/clojure/clojure/tools/analyzer/ast.clj#L63" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.ast/walk">walk</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (walk ast pre post)
       (walk ast pre post reversed?)
</pre>
    <pre id="var-docstr">Walk the ast applying `pre` when entering the nodes, and `post` when exiting.
Both functions must return a valid node since the returned value will replace
the node in the AST which was given as input to the function.
If reversed? is not-nil, `pre` and `post` will be applied starting from the last
children of the AST node to the first one.</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/0bda3061cb95162feafb94a288422ae18767b07a/src/main/clojure/clojure/tools/analyzer/ast.clj#L75" id="var-source">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.tools.analyzer.ast.query">clojure.tools.analyzer.ast.query</h2>
<pre id="namespace-docstr">Utilities for querying tools.analyzer ASTs with Datomic</pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.ast.query/db">db</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (db asts)
</pre>
    <pre id="var-docstr">Given a list of ASTs, returns a representation of those
that can be used as a database in a Datomic Datalog query</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/87bc3a0a8faff84362e2cbd43e20774e869343fb/src/main/clojure/clojure/tools/analyzer/ast/query.clj#L77" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.ast.query/q">q</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (q query asts &amp; inputs)
</pre>
    <pre id="var-docstr">Execute a Datomic Datalog query against the ASTs.
The first input is always assumed to be an AST database, if more
are required, it's required to call `db` on them.
`unfold-expression-clauses` is automatically applied to the
query.</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/87bc3a0a8faff84362e2cbd43e20774e869343fb/src/main/clojure/clojure/tools/analyzer/ast/query.clj#L83" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.ast.query/query-map">query-map</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (query-map query)
</pre>
    <pre id="var-docstr">Transoforms a Datomic query from its vector representation to its map one.
If the given query is already in its map representation, the original query
is returned.</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/87bc3a0a8faff84362e2cbd43e20774e869343fb/src/main/clojure/clojure/tools/analyzer/ast/query.clj#L14" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.ast.query/resolve-calls">resolve-calls</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (resolve-calls query)
</pre>
    <pre id="var-docstr">Automatically replace fn name symbols in expression clauses with
their namespace qualified one if the symbol can be resolved in the
current namespace.</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/87bc3a0a8faff84362e2cbd43e20774e869343fb/src/main/clojure/clojure/tools/analyzer/ast/query.clj#L59" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.ast.query/unfold-expression-clauses">unfold-expression-clauses</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (unfold-expression-clauses query)
</pre>
    <pre id="var-docstr">Given a Datomic query, walk the :where clauses searching for
expression clauses with nested calls, unnesting those calls.

E.g {:where [[(inc (dec ?foo)) ?bar] ..] ..} will be transformed in
{:where [[(dec ?foo) ?1234] [(inc ?1234) ?bar] ..] ..}</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/87bc3a0a8faff84362e2cbd43e20774e869343fb/src/main/clojure/clojure/tools/analyzer/ast/query.clj#L29" id="var-source">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.tools.analyzer.env">clojure.tools.analyzer.env</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.env/*env*">*env*</h2>
    <span id="var-type">dynamic var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">Global env atom
Required options:
 * :namespaces an atom containing a map from namespace symbol to namespace map,
   the namespace map contains at least the following keys:
  ** :mappings a map of mappings of the namespace, symbol to var/class
  ** :aliases a map of the aliases of the namespace, symbol to symbol
  ** :ns a symbol representing the namespace</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/16abd6b3f3a85196c2addac42de4ff83519cf10f/src/main/clojure/clojure/tools/analyzer/env.clj#L12" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.env/deref-env">deref-env</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (deref-env)
</pre>
    <pre id="var-docstr">Returns the value of the current global env if bound, otherwise
throws an exception.</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/16abd6b3f3a85196c2addac42de4ff83519cf10f/src/main/clojure/clojure/tools/analyzer/env.clj#L44" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.env/ensure">ensure</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ensure env &amp; body)
</pre>
    <pre id="var-docstr">If *env* is not bound it binds it to env before executing the body</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/16abd6b3f3a85196c2addac42de4ff83519cf10f/src/main/clojure/clojure/tools/analyzer/env.clj#L36" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.env/with-env">with-env</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (with-env env &amp; body)
</pre>
    <pre id="var-docstr">Binds the global env to env, then executes the body</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/16abd6b3f3a85196c2addac42de4ff83519cf10f/src/main/clojure/clojure/tools/analyzer/env.clj#L22" id="var-source">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.tools.analyzer.passes">clojure.tools.analyzer.passes</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes/schedule">schedule</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (schedule passes &amp; [opts])
</pre>
    <pre id="var-docstr">Takes a set of Vars that represent tools.analyzer passes and returns a function
that takes an AST and applies all the passes and their dependencies to the AST,
trying to compose together as many passes as possible to reduce the number of
full tree traversals.

Each pass must have a :pass-info element in its Var's metadata and it must point
to a map with the following parameters (:before, :after and :affects are optional):
* :after    a set of Vars, the passes that must be run before this pass
* :before   a set of Vars, the passes that must be run after this pass
* :depends  a set of Vars, the passes this pass depends on, implies :after
* :walk     a keyword, one of:
              - :none if the pass does its own tree walking and cannot be composed
                      with other passes
              - :post if the pass requires a postwalk and can be composed with other
                      passes
              - :pre  if the pass requires a prewalk and can be composed with other
                      passes
              - :any  if the pass can be composed with other passes in both a prewalk
                      or a postwalk
* :affects  a set of Vars, this pass must be the last in the same tree traversal that all
            the specified passes must partecipate in
            This pass must take a function as argument and return the actual pass, the
            argument represents the reified tree traversal which the pass can use to
            control a recursive traversal

An opts map might be provided, valid parameters:
* :debug?   if true, returns a vector of the scheduled passes rather than the concrete
            function</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/1b0960a15313e90833c19c4c2035abcf8c13218a/src/main/clojure/clojure/tools/analyzer/passes.clj#L133" id="var-source">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.tools.analyzer.passes.add-binding-atom">clojure.tools.analyzer.passes.add-binding-atom</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes.add-binding-atom/add-binding-atom">add-binding-atom</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (add-binding-atom ast)
</pre>
    <pre id="var-docstr">Walks the AST and adds an atom-backed-map to every local binding,
the same atom will be shared between all occurences of that local.

The atom is put in the :atom field of the node.</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/967a4839b85bf42d4af76a89d4aa86cc5abca3f6/src/main/clojure/clojure/tools/analyzer/passes/add_binding_atom.clj#L27" id="var-source">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.tools.analyzer.passes.collect-closed-overs">clojure.tools.analyzer.passes.collect-closed-overs</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes.collect-closed-overs/collect-closed-overs">collect-closed-overs</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (collect-closed-overs ast)
</pre>
    <pre id="var-docstr">Attach closed-overs info to the AST as specified by the passes opts:
* :where       set of :op nodes where to attach the closed-overs
* :top-level?  if true attach closed-overs info to the top-level node</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/bb22749ae7f21bd06a7153e90cfa44946455617c/src/main/clojure/clojure/tools/analyzer/passes/collect_closed_overs.clj#L59" id="var-source">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.tools.analyzer.passes.constant-lifter">clojure.tools.analyzer.passes.constant-lifter</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes.constant-lifter/constant-lift">constant-lift</h2>
    <span id="var-type">multimethod</span><br />
    <pre id="var-usage">No usage documentation available</pre>
    <pre id="var-docstr">If the node represents a collection with no metadata, and every item of that
collection is a literal, transform the node to an equivalent :const node.</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/967a4839b85bf42d4af76a89d4aa86cc5abca3f6/src/main/clojure/clojure/tools/analyzer/passes/constant_lifter.clj#L12" id="var-source">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.tools.analyzer.passes.elide-meta">clojure.tools.analyzer.passes.elide-meta</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes.elide-meta/elide-meta">elide-meta</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (elide-meta ast)
</pre>
    <pre id="var-docstr">If elides is not empty and the AST node contains metadata,
dissoc all the keys in elides from the metadata.</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/b3b631708566d7718dd1a5d5498ef58871af4fec/src/main/clojure/clojure/tools/analyzer/passes/elide_meta.clj#L80" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes.elide-meta/elides">elides</h2>
    <span id="var-type">dynamic var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">A map of op keywords to predicate IFns.
The predicate will be used to indicate what map keys should be elided on
metadata of nodes for that op.
:all can be used to indicate what should be elided for every node with
metadata.
Defaults to {:all (set (:elide-meta *compiler-options*))}</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/b3b631708566d7718dd1a5d5498ef58871af4fec/src/main/clojure/clojure/tools/analyzer/passes/elide_meta.clj#L12" id="var-source">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.tools.analyzer.passes.emit-form">clojure.tools.analyzer.passes.emit-form</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes.emit-form/-emit-form*">-emit-form*</h2>
    <span id="var-type">dynamic function</span><br />
    <pre id="var-usage">Usage: (-emit-form* {:keys [form], :as ast} opts)
</pre>
    <pre id="var-docstr">Extension point for custom emit-form implementations, should be rebound
to a multimethod with custom emit-form :opts.</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/ae16dadeae7b6ebf5d6c5fe396d98b13a6caa3c6/src/main/clojure/clojure/tools/analyzer/passes/emit_form.clj#L14" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes.emit-form/emit-form">emit-form</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (emit-form ast)
       (emit-form ast opts)
</pre>
    <pre id="var-docstr">Return the form represented by the given AST.
Opts is a set of options, valid options are:
 * :hygienic</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/ae16dadeae7b6ebf5d6c5fe396d98b13a6caa3c6/src/main/clojure/clojure/tools/analyzer/passes/emit_form.clj#L24" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes.emit-form/emit-hygienic-form">emit-hygienic-form</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (emit-hygienic-form ast)
</pre>
    <pre id="var-docstr">Return an hygienic form represented by the given AST</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/ae16dadeae7b6ebf5d6c5fe396d98b13a6caa3c6/src/main/clojure/clojure/tools/analyzer/passes/emit_form.clj#L32" id="var-source">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.tools.analyzer.passes.index-vector-nodes">clojure.tools.analyzer.passes.index-vector-nodes</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes.index-vector-nodes/index-vector-nodes">index-vector-nodes</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (index-vector-nodes ast)
</pre>
    <pre id="var-docstr">Adds an :idx attribute to nodes in a vector children, representing the position
of the node vector.</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/967a4839b85bf42d4af76a89d4aa86cc5abca3f6/src/main/clojure/clojure/tools/analyzer/passes/index_vector_nodes.clj#L11" id="var-source">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.tools.analyzer.passes.source-info">clojure.tools.analyzer.passes.source-info</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes.source-info/source-info">source-info</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (source-info ast)
</pre>
    <pre id="var-docstr">Adds (when avaliable) :line, :column, :end-line, :end-column and :file info to the AST :env</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/967a4839b85bf42d4af76a89d4aa86cc5abca3f6/src/main/clojure/clojure/tools/analyzer/passes/source_info.clj#L17" id="var-source">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.tools.analyzer.passes.uniquify">clojure.tools.analyzer.passes.uniquify</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes.uniquify/uniquify-locals">uniquify-locals</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (uniquify-locals ast)
</pre>
    <pre id="var-docstr">Walks the AST performing alpha-conversion on the :name field
of :local/:binding nodes, invalidates :local map in :env field</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/967a4839b85bf42d4af76a89d4aa86cc5abca3f6/src/main/clojure/clojure/tools/analyzer/passes/uniquify.clj#L81" id="var-source">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.tools.analyzer.passes.warn-earmuff">clojure.tools.analyzer.passes.warn-earmuff</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes.warn-earmuff/warn-earmuff">warn-earmuff</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (warn-earmuff ast)
</pre>
    <pre id="var-docstr">Prints a warning to *err* if the AST node is a :def node and the
var name contains earmuffs but the var is not marked dynamic</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/967a4839b85bf42d4af76a89d4aa86cc5abca3f6/src/main/clojure/clojure/tools/analyzer/passes/warn_earmuff.clj#L12" id="var-source">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.tools.analyzer.utils">clojure.tools.analyzer.utils</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/-source-info">-source-info</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-source-info x env)
</pre>
    <pre id="var-docstr">Returns the source-info of x</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/3c490ce93d37b8ae507828d6c0ddb02d65f8270a/src/main/clojure/clojure/tools/analyzer/utils.clj#L185" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/arglist-for-arity">arglist-for-arity</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (arglist-for-arity fn argc)
</pre>
    <pre id="var-docstr">Takes a fn node and an argc and returns the matching arglist</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/3c490ce93d37b8ae507828d6c0ddb02d65f8270a/src/main/clojure/clojure/tools/analyzer/utils.clj#L169" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/boolean?">boolean?</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (boolean? x)
</pre>
    <pre id="var-docstr">Returns true if x is a boolean</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/3c490ce93d37b8ae507828d6c0ddb02d65f8270a/src/main/clojure/clojure/tools/analyzer/utils.clj#L96" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/butlast+last">butlast+last</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (butlast+last s)
</pre>
    <pre id="var-docstr">Returns same value as (juxt butlast last), but slightly more
efficient since it only traverses the input sequence s once, not
twice.</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/3c490ce93d37b8ae507828d6c0ddb02d65f8270a/src/main/clojure/clojure/tools/analyzer/utils.clj#L35" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/classify">classify</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (classify form)
</pre>
    <pre id="var-docstr">Returns a keyword describing the form type</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/3c490ce93d37b8ae507828d6c0ddb02d65f8270a/src/main/clojure/clojure/tools/analyzer/utils.clj#L101" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/const-val">const-val</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (const-val {:keys [op form val expr]})
</pre>
    <pre id="var-docstr">Returns the value of a constant node (either :quote or :const)</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/3c490ce93d37b8ae507828d6c0ddb02d65f8270a/src/main/clojure/clojure/tools/analyzer/utils.clj#L195" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/constant?">constant?</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (constant? var)
</pre>
    <pre id="var-docstr">Returns true if the var is a const</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/3c490ce93d37b8ae507828d6c0ddb02d65f8270a/src/main/clojure/clojure/tools/analyzer/utils.clj#L133" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/ctx">ctx</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (ctx env ctx)
</pre>
    <pre id="var-docstr">Returns a copy of the passed environment with :context set to ctx</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/3c490ce93d37b8ae507828d6c0ddb02d65f8270a/src/main/clojure/clojure/tools/analyzer/utils.clj#L25" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/dissoc-env">dissoc-env</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (dissoc-env ast)
</pre>
    <pre id="var-docstr">Dissocs :env from the ast</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/3c490ce93d37b8ae507828d6c0ddb02d65f8270a/src/main/clojure/clojure/tools/analyzer/utils.clj#L30" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/dynamic?">dynamic?</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (dynamic? var)
</pre>
    <pre id="var-docstr">Returns true if the var is dynamic</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/3c490ce93d37b8ae507828d6c0ddb02d65f8270a/src/main/clojure/clojure/tools/analyzer/utils.clj#L138" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/into!">into!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (into! to from)
</pre>
    <pre id="var-docstr">Like into, but for transients</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/3c490ce93d37b8ae507828d6c0ddb02d65f8270a/src/main/clojure/clojure/tools/analyzer/utils.clj#L15" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/macro?">macro?</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (macro? var)
</pre>
    <pre id="var-docstr">Returns true if the var maps to a macro</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/3c490ce93d37b8ae507828d6c0ddb02d65f8270a/src/main/clojure/clojure/tools/analyzer/utils.clj#L128" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/mmerge">mmerge</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">Same as (fn [m1 m2] (merge-with merge m2 m1))</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/3c490ce93d37b8ae507828d6c0ddb02d65f8270a/src/main/clojure/clojure/tools/analyzer/utils.clj#L208" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/obj?">obj?</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (obj? x)
</pre>
    <pre id="var-docstr">Returns true if x implements IObj</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/3c490ce93d37b8ae507828d6c0ddb02d65f8270a/src/main/clojure/clojure/tools/analyzer/utils.clj#L71" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/private?">private?</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (private? var)
</pre>
    <pre id="var-docstr">Returns true if the var is private</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/3c490ce93d37b8ae507828d6c0ddb02d65f8270a/src/main/clojure/clojure/tools/analyzer/utils.clj#L123" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/protocol-node?">protocol-node?</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (protocol-node? var)
</pre>
    <pre id="var-docstr">Returns true if the var maps to a protocol function</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/3c490ce93d37b8ae507828d6c0ddb02d65f8270a/src/main/clojure/clojure/tools/analyzer/utils.clj#L145" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/record?">record?</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (record? x)
</pre>
    <pre id="var-docstr">Returns true if x is a record</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/3c490ce93d37b8ae507828d6c0ddb02d65f8270a/src/main/clojure/clojure/tools/analyzer/utils.clj#L61" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/reference?">reference?</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (reference? x)
</pre>
    <pre id="var-docstr">Returns true if x implements IReference</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/3c490ce93d37b8ae507828d6c0ddb02d65f8270a/src/main/clojure/clojure/tools/analyzer/utils.clj#L76" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/regex?">regex?</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (regex? x)
</pre>
    <pre id="var-docstr">Returns true if x is a regex</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/3c490ce93d37b8ae507828d6c0ddb02d65f8270a/src/main/clojure/clojure/tools/analyzer/utils.clj#L88" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/resolve-ns">resolve-ns</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (resolve-ns ns-sym {:keys [ns]})
</pre>
    <pre id="var-docstr">Resolves the ns mapped by the given sym in the env</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/3c490ce93d37b8ae507828d6c0ddb02d65f8270a/src/main/clojure/clojure/tools/analyzer/utils.clj#L150" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/resolve-var">resolve-var</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (resolve-var sym {:keys [ns], :as env})
</pre>
    <pre id="var-docstr">Resolves the var mapped by the given sym in the env</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/3c490ce93d37b8ae507828d6c0ddb02d65f8270a/src/main/clojure/clojure/tools/analyzer/utils.clj#L158" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/rseqv">rseqv</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (rseqv v)
</pre>
    <pre id="var-docstr">Same as (comp vec rseq)</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/3c490ce93d37b8ae507828d6c0ddb02d65f8270a/src/main/clojure/clojure/tools/analyzer/utils.clj#L20" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/source-info">source-info</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (source-info m)
</pre>
    <pre id="var-docstr">Returns the available source-info keys from a map</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/3c490ce93d37b8ae507828d6c0ddb02d65f8270a/src/main/clojure/clojure/tools/analyzer/utils.clj#L180" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/type?">type?</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (type? x)
</pre>
    <pre id="var-docstr">Returns true if x is a type</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/3c490ce93d37b8ae507828d6c0ddb02d65f8270a/src/main/clojure/clojure/tools/analyzer/utils.clj#L66" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/update-keys">update-keys</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (update-keys m f)
</pre>
    <pre id="var-docstr">Applies f to all the keys in the map</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/3c490ce93d37b8ae507828d6c0ddb02d65f8270a/src/main/clojure/clojure/tools/analyzer/utils.clj#L51" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/update-kv">update-kv</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (update-kv m f)
</pre>
    <pre id="var-docstr">Applies f to all the keys and vals in the map</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/3c490ce93d37b8ae507828d6c0ddb02d65f8270a/src/main/clojure/clojure/tools/analyzer/utils.clj#L56" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/update-vals">update-vals</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (update-vals m f)
</pre>
    <pre id="var-docstr">Applies f to all the vals in the map</pre>
    
    
    <a href="https://github.com/clojure/tools.analyzer/blob/3c490ce93d37b8ae507828d6c0ddb02d65f8270a/src/main/clojure/clojure/tools/analyzer/utils.clj#L46" id="var-source">Source</a>
  </div>
</div>


</div>
              </div>
            </div>
          </div>
	</div>
	<div id="foot">
	  <div style="text-align: center;" id="copyright">Copyright 2007-2014 by Rich Hickey and the various contributors</div>
	</div>
      </div>
      <div id="DesignedBy">Logo &amp; site design by <a title="Visit Tom Hickey's website." href="http://www.tomhickey.com">Tom Hickey</a>.<br />
      Clojure auto-documentation system by Tom Faulhaber.</div>
    </div>
    <!-- /AllContentContainer -->
  </body>

</html>